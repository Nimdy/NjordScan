"""
Intelligent Vulnerability Prioritizer

Prioritizes vulnerabilities based on multiple factors including business impact, exploitability, and context.
"""

import time
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class PriorityLevel(Enum):
    """Priority levels for vulnerabilities."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"

class ActionCategory(Enum):
    """Action categories for vulnerability response."""
    IMMEDIATE_FIX = "immediate_fix"
    URGENT_PATCH = "urgent_patch"
    SCHEDULED_REMEDIATION = "scheduled_remediation"
    MONITOR_AND_ASSESS = "monitor_and_assess"
    ACCEPT_RISK = "accept_risk"

@dataclass
class PriorityScore:
    """Detailed priority scoring for a vulnerability."""
    vulnerability_id: str
    overall_priority_score: float  # 0.0 to 100.0
    priority_level: PriorityLevel
    action_category: ActionCategory
    
    # Component scores
    risk_score: float = 0.0
    business_impact_score: float = 0.0
    exploitability_score: float = 0.0
    exposure_score: float = 0.0
    remediation_urgency_score: float = 0.0
    
    # Contextual factors
    has_exploit_available: bool = False
    is_publicly_accessible: bool = False
    affects_critical_system: bool = False
    has_compliance_implications: bool = False
    is_in_attack_path: bool = False
    
    # Timeline recommendations
    recommended_fix_timeline: str = "medium_term"  # immediate, short_term, medium_term, long_term
    estimated_effort: str = "medium"  # low, medium, high
    
    # Justification and reasoning
    priority_factors: List[str] = field(default_factory=list)
    mitigating_factors: List[str] = field(default_factory=list)
    escalation_triggers: List[str] = field(default_factory=list)
    
    # Dependencies and relationships
    blocks_other_fixes: List[str] = field(default_factory=list)
    depends_on_fixes: List[str] = field(default_factory=list)
    related_vulnerabilities: List[str] = field(default_factory=list)

@dataclass
class PrioritizationContext:
    """Context information for prioritization."""
    organization_type: str = "general"  # financial, healthcare, government, ecommerce, etc.
    risk_tolerance: str = "medium"  # low, medium, high
    compliance_frameworks: List[str] = field(default_factory=list)
    business_hours_criticality: bool = True
    maintenance_windows: List[str] = field(default_factory=list)
    available_resources: str = "medium"  # low, medium, high
    
    # Threat landscape
    active_threat_campaigns: List[str] = field(default_factory=list)
    recent_incidents: List[str] = field(default_factory=list)
    threat_intelligence: Dict[str, Any] = field(default_factory=dict)

class VulnerabilityPrioritizer:
    """Intelligent vulnerability prioritizer using multiple algorithms."""
    
    def __init__(self):
        # Prioritization weights for different factors
        self.priority_weights = {
            'risk_score': 0.25,
            'business_impact': 0.20,
            'exploitability': 0.20,
            'exposure': 0.15,
            'remediation_urgency': 0.10,
            'contextual_factors': 0.10
        }
        
        # Industry-specific priority adjustments
        self.industry_adjustments = {
            'financial': {
                'data_breach': 2.0,
                'regulatory_compliance': 1.8,
                'availability': 1.5,
                'reputation': 1.6
            },
            'healthcare': {
                'data_breach': 2.2,
                'regulatory_compliance': 2.0,
                'patient_safety': 2.5,
                'availability': 1.8
            },
            'government': {
                'data_breach': 2.5,
                'national_security': 3.0,
                'regulatory_compliance': 2.2,
                'public_trust': 2.0
            },
            'ecommerce': {
                'data_breach': 1.8,
                'availability': 2.2,
                'customer_trust': 1.8,
                'financial_loss': 2.0
            }
        }
        
        # Threat intelligence integration
        self.threat_intelligence = {
            'active_exploits': {},
            'trending_vulnerabilities': [],
            'apt_campaigns': []
        }
        
        # Statistics and learning
        self.prioritization_stats = {
            'total_prioritized': 0,
            'critical_priorities': 0,
            'high_priorities': 0,
            'average_priority_score': 0.0,
            'timeline_distribution': {}
        }
    
    def prioritize_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]], 
                                 risk_assessments: Optional[List[Any]] = None,
                                 correlations: Optional[List[Any]] = None,
                                 context: Optional[PrioritizationContext] = None) -> List[PriorityScore]:
        """Prioritize a list of vulnerabilities."""
        
        context = context or PrioritizationContext()
        
        priority_scores = []
        
        # Create risk assessment lookup
        risk_lookup = {}
        if risk_assessments:
            risk_lookup = {ra.vulnerability_id: ra for ra in risk_assessments}
        
        # Create correlation lookup
        correlation_lookup = self._build_correlation_lookup(correlations or [])
        
        for vulnerability in vulnerabilities:
            vuln_id = vulnerability.get('id', str(hash(str(vulnerability))))
            
            # Get associated risk assessment
            risk_assessment = risk_lookup.get(vuln_id)
            
            # Get associated correlations
            vuln_correlations = correlation_lookup.get(vuln_id, [])
            
            # Calculate priority score
            priority_score = self._calculate_priority_score(
                vulnerability, risk_assessment, vuln_correlations, context
            )
            
            priority_scores.append(priority_score)
        
        # Sort by priority score (highest first)
        priority_scores.sort(key=lambda x: x.overall_priority_score, reverse=True)
        
        # Apply dependency-based adjustments
        priority_scores = self._adjust_for_dependencies(priority_scores)
        
        # Update statistics
        self._update_prioritization_stats(priority_scores)
        
        logger.info(f"Prioritized {len(priority_scores)} vulnerabilities")
        
        return priority_scores
    
    def _calculate_priority_score(self, vulnerability: Dict[str, Any],
                                risk_assessment: Optional[Any] = None,
                                correlations: Optional[List[Any]] = None,
                                context: PrioritizationContext = None) -> PriorityScore:
        """Calculate comprehensive priority score for a vulnerability."""
        
        vuln_id = vulnerability.get('id', str(hash(str(vulnerability))))
        
        # Initialize priority score
        priority_score = PriorityScore(
            vulnerability_id=vuln_id,
            overall_priority_score=0.0,
            priority_level=PriorityLevel.MEDIUM,
            action_category=ActionCategory.SCHEDULED_REMEDIATION
        )
        
        # Calculate component scores
        priority_score.risk_score = self._calculate_risk_component(vulnerability, risk_assessment)
        priority_score.business_impact_score = self._calculate_business_impact_component(
            vulnerability, risk_assessment, context
        )
        priority_score.exploitability_score = self._calculate_exploitability_component(
            vulnerability, context
        )
        priority_score.exposure_score = self._calculate_exposure_component(vulnerability, context)
        priority_score.remediation_urgency_score = self._calculate_remediation_urgency_component(
            vulnerability, context
        )
        
        # Calculate contextual factors
        contextual_score, contextual_factors = self._calculate_contextual_factors(
            vulnerability, correlations, context
        )
        
        # Combine scores using weights
        overall_score = (
            priority_score.risk_score * self.priority_weights['risk_score'] +
            priority_score.business_impact_score * self.priority_weights['business_impact'] +
            priority_score.exploitability_score * self.priority_weights['exploitability'] +
            priority_score.exposure_score * self.priority_weights['exposure'] +
            priority_score.remediation_urgency_score * self.priority_weights['remediation_urgency'] +
            contextual_score * self.priority_weights['contextual_factors']
        )
        
        # Apply industry-specific adjustments
        industry_multiplier = self._get_industry_multiplier(vulnerability, context)
        overall_score *= industry_multiplier
        
        # Apply threat intelligence adjustments
        threat_multiplier = self._get_threat_intelligence_multiplier(vulnerability)
        overall_score *= threat_multiplier
        
        priority_score.overall_priority_score = min(100.0, overall_score)
        
        # Determine priority level and action category
        priority_score.priority_level = self._determine_priority_level(overall_score)
        priority_score.action_category = self._determine_action_category(
            overall_score, priority_score, context
        )
        
        # Set contextual flags
        self._set_contextual_flags(priority_score, vulnerability, correlations, context)
        
        # Determine timeline and effort
        priority_score.recommended_fix_timeline = self._determine_fix_timeline(
            priority_score.priority_level, priority_score.action_category
        )
        priority_score.estimated_effort = self._estimate_remediation_effort(vulnerability)
        
        # Generate justification
        priority_score.priority_factors = self._generate_priority_factors(
            priority_score, vulnerability, contextual_factors
        )
        priority_score.mitigating_factors = self._identify_mitigating_factors(
            vulnerability, context
        )
        priority_score.escalation_triggers = self._identify_escalation_triggers(
            priority_score, context
        )
        
        return priority_score
    
    def _calculate_risk_component(self, vulnerability: Dict[str, Any], 
                                risk_assessment: Optional[Any] = None) -> float:
        """Calculate risk component of priority score."""
        
        if risk_assessment:
            # Use comprehensive risk assessment
            return risk_assessment.overall_risk_score * 10.0  # Convert to 0-100 scale
        
        # Fallback to basic severity mapping
        severity = vulnerability.get('severity', 'medium').lower()
        severity_scores = {
            'critical': 90.0,
            'high': 70.0,
            'medium': 50.0,
            'low': 30.0,
            'info': 10.0
        }
        
        return severity_scores.get(severity, 50.0)
    
    def _calculate_business_impact_component(self, vulnerability: Dict[str, Any],
                                           risk_assessment: Optional[Any] = None,
                                           context: PrioritizationContext = None) -> float:
        """Calculate business impact component."""
        
        base_score = 50.0
        
        if risk_assessment:
            # Use business impact from risk assessment
            business_impact = risk_assessment.business_impact
            impact_scores = {
                'critical': 90.0,
                'high': 70.0,
                'moderate': 50.0,
                'low': 30.0,
                'minimal': 10.0
            }
            
            if hasattr(business_impact, 'value'):
                base_score = impact_scores.get(business_impact.value, 50.0)
            else:
                base_score = impact_scores.get(str(business_impact).lower(), 50.0)
        
        # Adjust based on context
        if context:
            # Compliance implications
            if context.compliance_frameworks:
                base_score *= 1.3
            
            # Organization type adjustments
            if context.organization_type in ['financial', 'healthcare', 'government']:
                base_score *= 1.2
            
            # Risk tolerance adjustments
            if context.risk_tolerance == 'low':
                base_score *= 1.4
            elif context.risk_tolerance == 'high':
                base_score *= 0.8
        
        return min(100.0, base_score)
    
    def _calculate_exploitability_component(self, vulnerability: Dict[str, Any],
                                          context: PrioritizationContext = None) -> float:
        """Calculate exploitability component."""
        
        base_score = 50.0
        
        # Check for known exploits
        vuln_type = vulnerability.get('vuln_type', '').lower()
        
        # High exploitability vulnerability types
        high_exploitability = {
            'sql_injection': 80.0,
            'command_injection': 85.0,
            'authentication_bypass': 90.0,
            'remote_code_execution': 95.0,
            'privilege_escalation': 75.0
        }
        
        # Medium exploitability
        medium_exploitability = {
            'xss': 60.0,
            'csrf': 55.0,
            'path_traversal': 65.0,
            'information_disclosure': 40.0
        }
        
        # Check vulnerability type
        for vuln_pattern, score in high_exploitability.items():
            if vuln_pattern in vuln_type:
                base_score = score
                break
        else:
            for vuln_pattern, score in medium_exploitability.items():
                if vuln_pattern in vuln_type:
                    base_score = score
                    break
        
        # Check for exploit availability indicators
        description = vulnerability.get('description', '').lower()
        if any(indicator in description for indicator in ['exploit', 'poc', 'proof of concept']):
            base_score *= 1.3
        
        # Active threat campaigns
        if context and context.active_threat_campaigns:
            if any(campaign in description for campaign in context.active_threat_campaigns):
                base_score *= 1.5
        
        return min(100.0, base_score)
    
    def _calculate_exposure_component(self, vulnerability: Dict[str, Any],
                                    context: PrioritizationContext = None) -> float:
        """Calculate exposure component."""
        
        base_score = 50.0
        
        # Check file path for exposure indicators
        file_path = vulnerability.get('file_path', '').lower()
        
        # High exposure paths
        if any(path in file_path for path in ['/api/', '/public/', '/pages/', 'frontend']):
            base_score = 80.0
        
        # Medium exposure paths
        elif any(path in file_path for path in ['/components/', '/lib/', '/utils/']):
            base_score = 60.0
        
        # Internal/backend paths
        elif any(path in file_path for path in ['/internal/', '/private/', '/admin/']):
            base_score = 30.0
        
        # Check vulnerability context
        if 'public' in vulnerability.get('description', '').lower():
            base_score *= 1.4
        
        if 'authenticated' in vulnerability.get('description', '').lower():
            base_score *= 0.7
        
        return min(100.0, base_score)
    
    def _calculate_remediation_urgency_component(self, vulnerability: Dict[str, Any],
                                               context: PrioritizationContext = None) -> float:
        """Calculate remediation urgency component."""
        
        base_score = 50.0
        
        # Check for urgency indicators
        description = vulnerability.get('description', '').lower()
        title = vulnerability.get('title', '').lower()
        
        # High urgency indicators
        if any(indicator in description or indicator in title 
               for indicator in ['critical', 'urgent', 'immediate', 'zero-day']):
            base_score = 90.0
        
        # Medium urgency indicators
        elif any(indicator in description or indicator in title
                for indicator in ['important', 'significant', 'major']):
            base_score = 70.0
        
        # Check for fix availability
        if vulnerability.get('fix') or vulnerability.get('recommendation'):
            base_score *= 1.2  # Easier to fix = higher urgency
        
        # Check remediation complexity
        vuln_type = vulnerability.get('vuln_type', '').lower()
        if any(complex_type in vuln_type for complex_type in ['design', 'architecture', 'logic']):
            base_score *= 0.8  # Complex fixes = lower urgency score
        
        return min(100.0, base_score)
    
    def _calculate_contextual_factors(self, vulnerability: Dict[str, Any],
                                    correlations: Optional[List[Any]] = None,
                                    context: PrioritizationContext = None) -> Tuple[float, List[str]]:
        """Calculate contextual factors score."""
        
        base_score = 50.0
        factors = []
        
        # Correlation-based factors
        if correlations:
            if len(correlations) > 2:
                base_score = 80.0
                factors.append(f"Part of {len(correlations)} vulnerability correlations")
            elif len(correlations) > 0:
                base_score = 65.0
                factors.append(f"Related to {len(correlations)} other vulnerabilities")
            
            # Check for attack chains
            attack_chains = [c for c in correlations 
                           if hasattr(c, 'correlation_type') and 'attack_chain' in str(c.correlation_type)]
            if attack_chains:
                base_score = 85.0
                factors.append("Part of potential attack chain")
        
        # Recent incidents
        if context and context.recent_incidents:
            vuln_type = vulnerability.get('vuln_type', '').lower()
            if any(vuln_type in incident.lower() for incident in context.recent_incidents):
                base_score *= 1.4
                factors.append("Similar to recent security incidents")
        
        # Compliance implications
        if context and context.compliance_frameworks:
            base_score *= 1.2
            factors.append(f"Compliance implications: {', '.join(context.compliance_frameworks)}")
        
        return min(100.0, base_score), factors
    
    def _get_industry_multiplier(self, vulnerability: Dict[str, Any],
                               context: PrioritizationContext = None) -> float:
        """Get industry-specific priority multiplier."""
        
        if not context or context.organization_type not in self.industry_adjustments:
            return 1.0
        
        industry_factors = self.industry_adjustments[context.organization_type]
        vuln_type = vulnerability.get('vuln_type', '').lower()
        description = vulnerability.get('description', '').lower()
        
        # Check for industry-specific risk factors
        multiplier = 1.0
        
        for factor, factor_multiplier in industry_factors.items():
            if factor in description or any(keyword in vuln_type 
                                          for keyword in factor.split('_')):
                multiplier = max(multiplier, factor_multiplier)
        
        return multiplier
    
    def _get_threat_intelligence_multiplier(self, vulnerability: Dict[str, Any]) -> float:
        """Get threat intelligence-based multiplier."""
        
        multiplier = 1.0
        vuln_type = vulnerability.get('vuln_type', '').lower()
        
        # Check against active exploits
        if vuln_type in self.threat_intelligence.get('active_exploits', {}):
            multiplier = 1.5
        
        # Check trending vulnerabilities
        if vuln_type in self.threat_intelligence.get('trending_vulnerabilities', []):
            multiplier = max(multiplier, 1.3)
        
        return multiplier
    
    def _determine_priority_level(self, overall_score: float) -> PriorityLevel:
        """Determine priority level from overall score."""
        
        if overall_score >= 85.0:
            return PriorityLevel.CRITICAL
        elif overall_score >= 70.0:
            return PriorityLevel.HIGH
        elif overall_score >= 50.0:
            return PriorityLevel.MEDIUM
        elif overall_score >= 30.0:
            return PriorityLevel.LOW
        else:
            return PriorityLevel.INFORMATIONAL
    
    def _determine_action_category(self, overall_score: float, 
                                 priority_score: PriorityScore,
                                 context: PrioritizationContext = None) -> ActionCategory:
        """Determine action category based on score and context."""
        
        # Critical scores require immediate action
        if overall_score >= 90.0:
            return ActionCategory.IMMEDIATE_FIX
        
        # High scores with exploitability require urgent patching
        if overall_score >= 80.0 and priority_score.exploitability_score >= 70.0:
            return ActionCategory.URGENT_PATCH
        
        # High scores require scheduled remediation
        if overall_score >= 70.0:
            return ActionCategory.URGENT_PATCH
        
        # Medium scores can be scheduled
        if overall_score >= 50.0:
            return ActionCategory.SCHEDULED_REMEDIATION
        
        # Low scores can be monitored
        if overall_score >= 30.0:
            return ActionCategory.MONITOR_AND_ASSESS
        
        # Very low scores might be acceptable
        return ActionCategory.ACCEPT_RISK
    
    def _set_contextual_flags(self, priority_score: PriorityScore,
                            vulnerability: Dict[str, Any],
                            correlations: Optional[List[Any]] = None,
                            context: PrioritizationContext = None):
        """Set contextual flags for priority score."""
        
        # Check for exploit availability
        description = vulnerability.get('description', '').lower()
        if any(indicator in description for indicator in ['exploit', 'poc', 'metasploit']):
            priority_score.has_exploit_available = True
        
        # Check for public accessibility
        file_path = vulnerability.get('file_path', '').lower()
        if any(path in file_path for path in ['/api/', '/public/', '/pages/']):
            priority_score.is_publicly_accessible = True
        
        # Check if affects critical system
        if any(critical in file_path for critical in ['/auth/', '/payment/', '/admin/']):
            priority_score.affects_critical_system = True
        
        # Check compliance implications
        if context and context.compliance_frameworks:
            priority_score.has_compliance_implications = True
        
        # Check if part of attack path
        if correlations:
            attack_chains = [c for c in correlations 
                           if hasattr(c, 'correlation_type') and 'attack_chain' in str(c.correlation_type)]
            if attack_chains:
                priority_score.is_in_attack_path = True
    
    def _determine_fix_timeline(self, priority_level: PriorityLevel, 
                              action_category: ActionCategory) -> str:
        """Determine recommended fix timeline."""
        
        if action_category == ActionCategory.IMMEDIATE_FIX:
            return "immediate"
        elif action_category == ActionCategory.URGENT_PATCH:
            return "short_term"
        elif priority_level in [PriorityLevel.HIGH, PriorityLevel.MEDIUM]:
            return "medium_term"
        else:
            return "long_term"
    
    def _estimate_remediation_effort(self, vulnerability: Dict[str, Any]) -> str:
        """Estimate remediation effort."""
        
        vuln_type = vulnerability.get('vuln_type', '').lower()
        
        # Low effort fixes
        if any(easy_fix in vuln_type for easy_fix in ['xss', 'csrf', 'header', 'configuration']):
            return "low"
        
        # High effort fixes
        if any(hard_fix in vuln_type for hard_fix in ['design', 'architecture', 'logic', 'crypto']):
            return "high"
        
        # Default to medium
        return "medium"
    
    def _generate_priority_factors(self, priority_score: PriorityScore,
                                 vulnerability: Dict[str, Any],
                                 contextual_factors: List[str]) -> List[str]:
        """Generate list of factors contributing to priority."""
        
        factors = []
        
        # Risk-based factors
        if priority_score.risk_score >= 80.0:
            factors.append(f"High risk score: {priority_score.risk_score:.1f}")
        
        # Business impact factors
        if priority_score.business_impact_score >= 70.0:
            factors.append(f"Significant business impact: {priority_score.business_impact_score:.1f}")
        
        # Exploitability factors
        if priority_score.exploitability_score >= 75.0:
            factors.append(f"High exploitability: {priority_score.exploitability_score:.1f}")
        
        # Exposure factors
        if priority_score.exposure_score >= 70.0:
            factors.append(f"High exposure level: {priority_score.exposure_score:.1f}")
        
        # Contextual factors
        factors.extend(contextual_factors)
        
        # Flags-based factors
        if priority_score.has_exploit_available:
            factors.append("Public exploit available")
        
        if priority_score.is_publicly_accessible:
            factors.append("Publicly accessible component")
        
        if priority_score.affects_critical_system:
            factors.append("Affects critical system component")
        
        return factors
    
    def _identify_mitigating_factors(self, vulnerability: Dict[str, Any],
                                   context: PrioritizationContext = None) -> List[str]:
        """Identify factors that mitigate the vulnerability's priority."""
        
        factors = []
        
        # Authentication requirements
        if 'authenticated' in vulnerability.get('description', '').lower():
            factors.append("Requires authentication")
        
        # Internal access only
        file_path = vulnerability.get('file_path', '').lower()
        if any(internal in file_path for internal in ['/internal/', '/private/', '/admin/']):
            factors.append("Internal access only")
        
        # Development environment
        if 'development' in vulnerability.get('description', '').lower():
            factors.append("Development environment only")
        
        # Fix available
        if vulnerability.get('fix') or vulnerability.get('recommendation'):
            factors.append("Fix/mitigation available")
        
        return factors
    
    def _identify_escalation_triggers(self, priority_score: PriorityScore,
                                    context: PrioritizationContext = None) -> List[str]:
        """Identify triggers that would escalate this vulnerability's priority."""
        
        triggers = []
        
        if priority_score.has_exploit_available:
            triggers.append("Public exploit becomes available")
        
        if priority_score.is_publicly_accessible:
            triggers.append("Evidence of active exploitation")
        
        if priority_score.affects_critical_system:
            triggers.append("System becomes business-critical")
        
        if context and context.compliance_frameworks:
            triggers.append("Compliance audit or assessment")
        
        triggers.append("Related vulnerability exploited in the wild")
        triggers.append("Threat intelligence indicates targeting")
        
        return triggers
    
    def _build_correlation_lookup(self, correlations: List[Any]) -> Dict[str, List[Any]]:
        """Build lookup dictionary for vulnerability correlations."""
        
        lookup = {}
        
        for correlation in correlations:
            # Add correlation to primary vulnerability
            primary_id = getattr(correlation, 'primary_vulnerability', None)
            if primary_id:
                if primary_id not in lookup:
                    lookup[primary_id] = []
                lookup[primary_id].append(correlation)
            
            # Add correlation to related vulnerabilities
            related_ids = getattr(correlation, 'related_vulnerabilities', [])
            for related_id in related_ids:
                if related_id not in lookup:
                    lookup[related_id] = []
                lookup[related_id].append(correlation)
        
        return lookup
    
    def _adjust_for_dependencies(self, priority_scores: List[PriorityScore]) -> List[PriorityScore]:
        """Adjust priorities based on dependencies between vulnerabilities."""
        
        # This is a simplified implementation - in production, this would involve
        # more sophisticated dependency analysis
        
        for score in priority_scores:
            # If this vulnerability blocks other fixes, increase priority
            if score.blocks_other_fixes:
                score.overall_priority_score *= 1.2
                score.priority_factors.append("Blocks other vulnerability fixes")
            
            # If this depends on other fixes, it might be deprioritized
            if score.depends_on_fixes:
                score.overall_priority_score *= 0.9
                score.priority_factors.append("Depends on other fixes")
        
        # Re-sort after adjustments
        priority_scores.sort(key=lambda x: x.overall_priority_score, reverse=True)
        
        return priority_scores
    
    def _update_prioritization_stats(self, priority_scores: List[PriorityScore]):
        """Update prioritization statistics."""
        
        self.prioritization_stats['total_prioritized'] = len(priority_scores)
        
        # Count by priority level
        critical_count = sum(1 for ps in priority_scores if ps.priority_level == PriorityLevel.CRITICAL)
        high_count = sum(1 for ps in priority_scores if ps.priority_level == PriorityLevel.HIGH)
        
        self.prioritization_stats['critical_priorities'] = critical_count
        self.prioritization_stats['high_priorities'] = high_count
        
        # Calculate average priority score
        if priority_scores:
            avg_score = sum(ps.overall_priority_score for ps in priority_scores) / len(priority_scores)
            self.prioritization_stats['average_priority_score'] = avg_score
        
        # Timeline distribution
        timeline_dist = {}
        for ps in priority_scores:
            timeline = ps.recommended_fix_timeline
            timeline_dist[timeline] = timeline_dist.get(timeline, 0) + 1
        
        self.prioritization_stats['timeline_distribution'] = timeline_dist
    
    def get_prioritization_statistics(self) -> Dict[str, Any]:
        """Get prioritization statistics."""
        return dict(self.prioritization_stats)
    
    def get_top_priorities(self, priority_scores: List[PriorityScore], 
                          count: int = 10) -> List[PriorityScore]:
        """Get top N priority vulnerabilities."""
        return sorted(priority_scores, key=lambda x: x.overall_priority_score, reverse=True)[:count]
    
    def get_immediate_action_items(self, priority_scores: List[PriorityScore]) -> List[PriorityScore]:
        """Get vulnerabilities requiring immediate action."""
        return [ps for ps in priority_scores 
                if ps.action_category in [ActionCategory.IMMEDIATE_FIX, ActionCategory.URGENT_PATCH]]
    
    def update_threat_intelligence(self, threat_data: Dict[str, Any]):
        """Update threat intelligence data for better prioritization."""
        
        if 'active_exploits' in threat_data:
            self.threat_intelligence['active_exploits'].update(threat_data['active_exploits'])
        
        if 'trending_vulnerabilities' in threat_data:
            self.threat_intelligence['trending_vulnerabilities'] = threat_data['trending_vulnerabilities']
        
        if 'apt_campaigns' in threat_data:
            self.threat_intelligence['apt_campaigns'] = threat_data['apt_campaigns']
        
        logger.info("Updated threat intelligence data for prioritization")
