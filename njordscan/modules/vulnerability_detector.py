#!/usr/bin/env python3
"""
üîç Advanced Vulnerability Detection Engine
Comprehensive security scanning with multiple detection patterns.
"""

import re
import json
import ast
from pathlib import Path
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse, parse_qs
import requests
from bs4 import BeautifulSoup

from .base import BaseModule, Vulnerability

class VulnerabilityDetector(BaseModule):
    """Advanced vulnerability detection with multiple patterns."""
    
    def __init__(self, config=None, vuln_id_generator=None):
        # Create default vuln_id_generator if none provided
        if vuln_id_generator is None:
            from ..vulnerability import VulnerabilityIdGenerator
            vuln_id_generator = VulnerabilityIdGenerator()
        
        # Create default config if none provided
        if config is None:
            from ..config import Config
            config = Config()
            
        super().__init__(config, vuln_id_generator)
        self.name = "Advanced Vulnerability Detector"
        self.description = "Comprehensive security scanning with multiple detection patterns"
        
        # Initialize logger
        import logging
        self.logger = logging.getLogger(__name__)
        
        # Detection patterns
        self.patterns = {
            'xss': {
                'reflected': [
                    r'<script[^>]*>.*?</script>',
                    r'javascript:',
                    r'on\w+\s*=',
                    r'<iframe[^>]*>',
                    r'<object[^>]*>',
                    r'<embed[^>]*>'
                ],
                'stored': [
                    r'<script[^>]*>.*?</script>',
                    r'javascript:',
                    r'on\w+\s*='
                ]
            },
            'sql_injection': {
                'error_based': [
                    r'SQL syntax.*MySQL',
                    r'ORA-\d{5}',
                    r'PostgreSQL.*ERROR',
                    r'SQLite.*syntax error',
                    r'Microsoft.*Database.*Error'
                ],
                'boolean_based': [
                    r'AND\s+\d+\s*=\s*\d+',
                    r'OR\s+\d+\s*=\s*\d+',
                    r'UNION\s+SELECT'
                ]
            },
            'csrf': [
                r'<form[^>]*>',
                r'<input[^>]*type\s*=\s*["\']hidden["\'][^>]*>'
            ],
            'ssrf': [
                r'http://',
                r'https://',
                r'ftp://',
                r'file://',
                r'gopher://'
            ],
            'path_traversal': [
                r'\.\./',
                r'\.\.\\',
                r'%2e%2e%2f',
                r'%2e%2e%5c'
            ],
            'command_injection': [
                r'[;&|`]',
                r'\$\{.*\}',
                r'`.*`',
                r'exec\s*\(',
                r'system\s*\('
            ],
            'file_upload': [
                r'\.php$',
                r'\.jsp$',
                r'\.asp$',
                r'\.exe$',
                r'\.bat$',
                r'\.sh$'
            ],
            'open_redirect': [
                r'redirect\s*=\s*[^\s&]+',
                r'url\s*=\s*[^\s&]+',
                r'next\s*=\s*[^\s&]+',
                r'return\s*=\s*[^\s&]+'
            ]
        }
        
        # Framework-specific patterns
        self.framework_patterns = {
            'nextjs': {
                'api_routes': [
                    r'pages/api/.*\.(js|ts|jsx|tsx)$',
                    r'app/api/.*/route\.(js|ts|jsx|tsx)$'
                ],
                'middleware': [
                    r'middleware\.(js|ts)$',
                    r'_middleware\.(js|ts)$'
                ],
                'environment_vars': [
                    r'process\.env\.',
                    r'NEXT_PUBLIC_'
                ]
            },
            'react': {
                'dangerous_html': [
                    r'dangerouslySetInnerHTML',
                    r'innerHTML\s*='
                ],
                'event_handlers': [
                    r'onClick\s*=',
                    r'onSubmit\s*=',
                    r'onChange\s*='
                ]
            },
            'vite': {
                'env_vars': [
                    r'import\.meta\.env\.',
                    r'VITE_'
                ],
                'config_files': [
                    r'vite\.config\.(js|ts)$'
                ]
            },
            'express': {
                'middleware': [
                    r'app\.use\(',
                    r'express\.static\('
                ],
                'routes': [
                    r'app\.(get|post|put|delete)\(',
                    r'router\.(get|post|put|delete)\('
                ]
            }
        }
        
        # False positive indicators
        self.false_positive_indicators = {
            'xss': [
                r'innerHTML\s*=\s*["\']\s*$',  # Empty innerHTML
                r'textContent\s*=',  # Safe text content
                r'innerText\s*='  # Safe inner text
            ],
            'sql_injection': [
                r'SELECT\s+.*\s+FROM\s+\w+',  # Valid SQL queries
                r'INSERT\s+INTO\s+\w+',  # Valid SQL queries
                r'UPDATE\s+\w+\s+SET'  # Valid SQL queries
            ]
        }

    async def scan(self, target: str) -> List[Vulnerability]:
        """
        Main scan method that must be implemented by all modules.
        
        Args:
            target: Target URL or directory path
            
        Returns:
            List of Vulnerability objects
        """
        if self._is_url(target):
            return self.scan_url(target)
        else:
            # For directory targets, scan all files
            vulnerabilities = []
            target_path = Path(target)
            if target_path.is_dir():
                for file_path in target_path.rglob('*'):
                    if file_path.is_file():
                        vulnerabilities.extend(self.scan_file(file_path))
            return vulnerabilities
    
    def _is_url(self, target: str) -> bool:
        """Check if target is a URL."""
        return target.startswith(('http://', 'https://', 'ftp://'))
    
    def scan_file(self, file_path: Path) -> List[Vulnerability]:
        """Scan a single file for vulnerabilities."""
        vulnerabilities = []
        
        try:
            if not file_path.exists():
                return vulnerabilities
                
            content = file_path.read_text(encoding='utf-8', errors='ignore')
            file_extension = file_path.suffix.lower()
            
            # Detect framework
            framework = self._detect_framework(file_path, content)
            
            # Scan for general vulnerabilities
            vulnerabilities.extend(self._scan_general_patterns(content, file_path))
            
            # Scan for framework-specific vulnerabilities
            if framework:
                vulnerabilities.extend(self._scan_framework_patterns(content, file_path, framework))
            
            # Scan for language-specific vulnerabilities
            vulnerabilities.extend(self._scan_language_patterns(content, file_path, file_extension))
            
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
            
        return vulnerabilities

    def scan_url(self, url: str) -> List[Vulnerability]:
        """Scan a URL for vulnerabilities."""
        vulnerabilities = []
        
        try:
            # Test for common vulnerabilities
            vulnerabilities.extend(self._test_xss_reflected(url))
            vulnerabilities.extend(self._test_sql_injection(url))
            vulnerabilities.extend(self._test_open_redirect(url))
            vulnerabilities.extend(self._test_ssrf(url))
            
        except Exception as e:
            self.logger.error(f"Error scanning URL {url}: {e}")
            
        return vulnerabilities

    def _detect_framework(self, file_path: Path, content: str) -> Optional[str]:
        """Detect the framework used in the file."""
        # Check file path patterns
        if any(re.search(pattern, str(file_path)) for pattern in self.framework_patterns['nextjs']['api_routes']):
            return 'nextjs'
        elif any(re.search(pattern, str(file_path)) for pattern in self.framework_patterns['react']['dangerous_html']):
            return 'react'
        elif any(re.search(pattern, str(file_path)) for pattern in self.framework_patterns['vite']['config_files']):
            return 'vite'
        elif any(re.search(pattern, str(file_path)) for pattern in self.framework_patterns['express']['routes']):
            return 'express'
            
        # Check content patterns
        if 'next' in content.lower() and 'import' in content:
            return 'nextjs'
        elif 'react' in content.lower() and 'import' in content:
            return 'react'
        elif 'vite' in content.lower() and 'import' in content:
            return 'vite'
        elif 'express' in content.lower() and 'require' in content:
            return 'express'
            
        return None

    def _scan_general_patterns(self, content: str, file_path: Path) -> List[Vulnerability]:
        """Scan for general vulnerability patterns."""
        vulnerabilities = []
        
        for vuln_type, patterns in self.patterns.items():
            if isinstance(patterns, dict):
                # Handle nested patterns (like XSS with reflected/stored)
                for sub_type, sub_patterns in patterns.items():
                    vulnerabilities.extend(self._check_patterns(
                        content, sub_patterns, f"{vuln_type}_{sub_type}", file_path
                    ))
            else:
                # Handle simple patterns
                vulnerabilities.extend(self._check_patterns(
                    content, patterns, vuln_type, file_path
                ))
                
        return vulnerabilities

    def _scan_framework_patterns(self, content: str, file_path: Path, framework: str) -> List[Vulnerability]:
        """Scan for framework-specific vulnerabilities."""
        vulnerabilities = []
        
        if framework in self.framework_patterns:
            framework_patterns = self.framework_patterns[framework]
            
            for pattern_type, patterns in framework_patterns.items():
                vulnerabilities.extend(self._check_patterns(
                    content, patterns, f"{framework}_{pattern_type}", file_path
                ))
                
        return vulnerabilities

    def _scan_language_patterns(self, content: str, file_path: Path, extension: str) -> List[Vulnerability]:
        """Scan for language-specific vulnerabilities."""
        vulnerabilities = []
        
        if extension in ['.js', '.jsx', '.ts', '.tsx']:
            vulnerabilities.extend(self._scan_javascript_patterns(content, file_path))
        elif extension in ['.py']:
            vulnerabilities.extend(self._scan_python_patterns(content, file_path))
        elif extension in ['.php']:
            vulnerabilities.extend(self._scan_php_patterns(content, file_path))
        elif extension in ['.java']:
            vulnerabilities.extend(self._scan_java_patterns(content, file_path))
            
        return vulnerabilities

    def _check_patterns(self, content: str, patterns: List[str], vuln_type: str, file_path: Path) -> List[Vulnerability]:
        """Check content against vulnerability patterns."""
        vulnerabilities = []
        
        for pattern in patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
            
            for match in matches:
                # Check for false positives
                if self._is_false_positive(content, match, vuln_type):
                    continue
                    
                line_number = content[:match.start()].count('\n') + 1
                code_snippet = self._extract_code_snippet(content, match.start(), match.end())
                
                vulnerability = self.create_vulnerability(
                    title=f"{vuln_type.replace('_', ' ').title()} Vulnerability",
                    description=f"Potential {vuln_type} vulnerability detected",
                    severity=self._get_severity(vuln_type),
                    vuln_type=vuln_type,
                    file_path=str(file_path),
                    line_number=line_number,
                    code_snippet=code_snippet,
                    fix=self._get_fix_guide(vuln_type),
                    reference=self._get_reference(vuln_type)
                )
                
                vulnerabilities.append(vulnerability)
                
        return vulnerabilities

    def _is_false_positive(self, content: str, match: re.Match, vuln_type: str) -> bool:
        """Check if a match is likely a false positive."""
        if vuln_type in self.false_positive_indicators:
            # Check if the matched content is followed by safe patterns
            after_match = content[match.end():match.end() + 100]
            for safe_pattern in self.false_positive_indicators[vuln_type]:
                if re.search(safe_pattern, after_match, re.IGNORECASE):
                    return True
        return False

    def _extract_code_snippet(self, content: str, start: int, end: int, context: int = 3) -> str:
        """Extract code snippet with context."""
        lines = content.split('\n')
        start_line = max(0, content[:start].count('\n') - context)
        end_line = min(len(lines), content[:end].count('\n') + context + 1)
        
        snippet_lines = []
        for i in range(start_line, end_line):
            prefix = ">>> " if i == content[:start].count('\n') else "    "
            snippet_lines.append(f"{prefix}{lines[i]}")
            
        return '\n'.join(snippet_lines)

    def _get_severity(self, vuln_type: str) -> str:
        """Get severity level for vulnerability type."""
        high_severity = ['xss', 'sql_injection', 'command_injection', 'ssrf']
        medium_severity = ['csrf', 'path_traversal', 'file_upload']
        low_severity = ['open_redirect']
        
        if any(high in vuln_type for high in high_severity):
            return 'high'
        elif any(medium in vuln_type for medium in medium_severity):
            return 'medium'
        else:
            return 'low'

    def _get_fix_guide(self, vuln_type: str) -> str:
        """Get fix guide for vulnerability type."""
        fix_guides = {
            'xss': 'Use proper output encoding and avoid innerHTML. Use textContent or innerText instead.',
            'sql_injection': 'Use parameterized queries or prepared statements. Never concatenate user input into SQL queries.',
            'csrf': 'Implement CSRF tokens in forms and validate them on the server side.',
            'ssrf': 'Validate and sanitize all URLs. Use allowlists for external domains.',
            'path_traversal': 'Validate file paths and use path normalization. Restrict access to intended directories.',
            'command_injection': 'Avoid executing system commands with user input. Use safe alternatives when possible.',
            'file_upload': 'Validate file types, scan for malware, and store files outside web root.',
            'open_redirect': 'Validate redirect URLs and use allowlists for external domains.'
        }
        
        return fix_guides.get(vuln_type, 'Implement proper input validation and output encoding.')

    def _get_reference(self, vuln_type: str) -> str:
        """Get reference link for vulnerability type."""
        references = {
            'xss': 'https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)',
            'sql_injection': 'https://owasp.org/www-project-top-ten/2017/A1_2017-Injection',
            'csrf': 'https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration',
            'ssrf': 'https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging_&_Monitoring',
            'path_traversal': 'https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control',
            'command_injection': 'https://owasp.org/www-project-top-ten/2017/A1_2017-Injection',
            'file_upload': 'https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration',
            'open_redirect': 'https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration'
        }
        
        return references.get(vuln_type, 'https://owasp.org/www-project-top-ten/')

    def _test_xss_reflected(self, url: str) -> List[Vulnerability]:
        """Test for reflected XSS vulnerabilities."""
        vulnerabilities = []
        test_payloads = [
            '<script>alert("XSS")</script>',
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '"><script>alert("XSS")</script>'
        ]
        
        try:
            for payload in test_payloads:
                # Test in query parameters
                parsed_url = urlparse(url)
                query_params = parse_qs(parsed_url.query)
                
                for param_name in query_params:
                    test_url = url.replace(f"{param_name}=", f"{param_name}={payload}")
                    response = requests.get(test_url, timeout=10)
                    
                    if payload in response.text:
                        vulnerability = self.create_vulnerability(
                            title="Reflected XSS Vulnerability",
                            description=f"XSS payload reflected in response for parameter '{param_name}'",
                            severity='high',
                            vuln_type='xss_reflected',
                            location=url,
                            code_snippet=f"Parameter: {param_name}\nPayload: {payload}",
                            fix="Implement proper input validation and output encoding. Use Content Security Policy headers.",
                            reference="https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)"
                        )
                        vulnerabilities.append(vulnerability)
                        
        except Exception as e:
            self.logger.error(f"Error testing XSS: {e}")
            
        return vulnerabilities

    def _test_sql_injection(self, url: str) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities."""
        vulnerabilities = []
        test_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT NULL--",
            "1' AND 1=1--"
        ]
        
        try:
            for payload in test_payloads:
                parsed_url = urlparse(url)
                query_params = parse_qs(parsed_url.query)
                
                for param_name in query_params:
                    test_url = url.replace(f"{param_name}=", f"{param_name}={payload}")
                    response = requests.get(test_url, timeout=10)
                    
                    # Check for SQL error messages
                    sql_errors = [
                        'SQL syntax', 'MySQL', 'ORA-', 'PostgreSQL', 'SQLite',
                        'Microsoft', 'Database', 'syntax error'
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            vulnerability = self.create_vulnerability(
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection detected in parameter '{param_name}'",
                                severity='high',
                                vuln_type='sql_injection',
                                location=url,
                                code_snippet=f"Parameter: {param_name}\nPayload: {payload}",
                                fix="Use parameterized queries or prepared statements. Never concatenate user input into SQL queries.",
                                reference="https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
                            )
                            vulnerabilities.append(vulnerability)
                            break
                            
        except Exception as e:
            self.logger.error(f"Error testing SQL injection: {e}")
            
        return vulnerabilities

    def _test_open_redirect(self, url: str) -> List[Vulnerability]:
        """Test for open redirect vulnerabilities."""
        vulnerabilities = []
        redirect_params = ['redirect', 'url', 'next', 'return', 'target']
        
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            for param_name in redirect_params:
                if param_name in query_params:
                    test_payload = "https://evil.com"
                    test_url = url.replace(f"{param_name}=", f"{param_name}={test_payload}")
                    
                    # Check if the URL parameter is used in redirects
                    response = requests.get(test_url, timeout=10, allow_redirects=False)
                    
                    if response.status_code in [301, 302, 303, 307, 308]:
                        location_header = response.headers.get('Location', '')
                        if test_payload in location_header:
                            vulnerability = self.create_vulnerability(
                                title="Open Redirect Vulnerability",
                                description=f"Open redirect detected in parameter '{param_name}'",
                                severity='medium',
                                vuln_type='open_redirect',
                                location=url,
                                code_snippet=f"Parameter: {param_name}\nRedirect URL: {location_header}",
                                fix="Validate redirect URLs and use allowlists for external domains.",
                                reference="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration"
                            )
                            vulnerabilities.append(vulnerability)
                            
        except Exception as e:
            self.logger.error(f"Error testing open redirect: {e}")
            
        return vulnerabilities

    def _test_ssrf(self, url: str) -> List[Vulnerability]:
        """Test for SSRF vulnerabilities."""
        vulnerabilities = []
        ssrf_params = ['url', 'uri', 'path', 'file', 'src', 'dest']
        
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            for param_name in ssrf_params:
                if param_name in query_params:
                    # Test with internal IP addresses
                    test_payloads = [
                        'http://127.0.0.1',
                        'http://localhost',
                        'file:///etc/passwd',
                        'http://169.254.169.254'  # AWS metadata
                    ]
                    
                    for payload in test_payloads:
                        test_url = url.replace(f"{param_name}=", f"{param_name}={payload}")
                        
                        try:
                            response = requests.get(test_url, timeout=5)
                            
                            # Check for internal information disclosure
                            if any(indicator in response.text.lower() for indicator in ['root:', 'localhost', 'internal']):
                                vulnerability = self.create_vulnerability(
                                    title="SSRF Vulnerability",
                                    description=f"Server-Side Request Forgery detected in parameter '{param_name}'",
                                    severity='high',
                                    vuln_type='ssrf',
                                    location=url,
                                    code_snippet=f"Parameter: {param_name}\nPayload: {payload}",
                                    fix="Validate and sanitize all URLs. Use allowlists for external domains.",
                                    reference="https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging_&_Monitoring"
                                )
                                vulnerabilities.append(vulnerability)
                                break
                                
                        except requests.exceptions.Timeout:
                            # Timeout might indicate internal service access
                            continue
                            
        except Exception as e:
            self.logger.error(f"Error testing SSRF: {e}")
            
        return vulnerabilities

    def _scan_javascript_patterns(self, content: str, file_path: Path) -> List[Vulnerability]:
        """Scan JavaScript/TypeScript files for vulnerabilities."""
        vulnerabilities = []
        
        # Check for eval usage
        if 'eval(' in content:
            vulnerability = self.create_vulnerability(
                title="Dangerous eval() Usage",
                description="eval() function can execute arbitrary code and is a security risk",
                severity='high',
                vuln_type='code_injection',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'eval('),
                fix="Replace eval() with safer alternatives like JSON.parse() or Function constructor with proper validation.",
                reference="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval"
            )
            vulnerabilities.append(vulnerability)
        
        # Check for innerHTML usage
        if 'innerHTML' in content:
            vulnerability = self.create_vulnerability(
                title="Dangerous innerHTML Usage",
                description="innerHTML can lead to XSS if used with untrusted content",
                severity='medium',
                vuln_type='xss',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'innerHTML'),
                fix="Use textContent or innerText instead. If HTML is needed, sanitize the content first.",
                reference="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML"
            )
            vulnerabilities.append(vulnerability)
        
        # Check for localStorage without validation
        if 'localStorage.setItem(' in content:
            vulnerability = self.create_vulnerability(
                title="Unvalidated localStorage Usage",
                description="localStorage can store sensitive data without proper validation",
                severity='low',
                vuln_type='data_exposure',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'localStorage.setItem('),
                fix="Validate all data before storing in localStorage. Never store sensitive information.",
                reference="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"
            )
            vulnerabilities.append(vulnerability)
            
        return vulnerabilities

    def _scan_python_patterns(self, content: str, file_path: Path) -> List[Vulnerability]:
        """Scan Python files for vulnerabilities."""
        vulnerabilities = []
        
        # Check for exec usage
        if 'exec(' in content:
            vulnerability = self.create_vulnerability(
                title="Dangerous exec() Usage",
                description="exec() function can execute arbitrary code and is a security risk",
                severity='high',
                vuln_type='code_injection',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'exec('),
                fix="Avoid exec() with user input. Use safer alternatives like ast.literal_eval() for simple expressions.",
                reference="https://docs.python.org/3/library/functions.html#exec"
            )
            vulnerabilities.append(vulnerability)
        
        # Check for shell=True in subprocess
        if 'subprocess.run(' in content and 'shell=True' in content:
            vulnerability = self.create_vulnerability(
                title="Dangerous subprocess with shell=True",
                description="shell=True can lead to command injection vulnerabilities",
                severity='high',
                vuln_type='command_injection',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'shell=True'),
                fix="Avoid shell=True. Use list arguments and proper argument parsing instead.",
                reference="https://docs.python.org/3/library/subprocess.html#security-considerations"
            )
            vulnerabilities.append(vulnerability)
        
        # Check for pickle usage
        if 'pickle.loads(' in content or 'pickle.load(' in content:
            vulnerability = self.create_vulnerability(
                title="Dangerous pickle Usage",
                description="pickle can execute arbitrary code during deserialization",
                severity='high',
                vuln_type='code_injection',
                file_path=str(file_path),
                code_snippet=self._extract_line_with_context(content, 'pickle.'),
                fix="Avoid pickle for untrusted data. Use JSON, YAML, or custom serialization instead.",
                reference="https://docs.python.org/3/library/pickle.html#security"
            )
            vulnerabilities.append(vulnerability)
            
        return vulnerabilities

    def _extract_line_with_context(self, content: str, search_term: str, context: int = 2) -> str:
        """Extract line with context around a search term."""
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            if search_term in line:
                start_line = max(0, i - context)
                end_line = min(len(lines), i + context + 1)
                
                snippet_lines = []
                for j in range(start_line, end_line):
                    prefix = ">>> " if j == i else "    "
                    snippet_lines.append(f"{prefix}{lines[j]}")
                    
                return '\n'.join(snippet_lines)
                
        return f"Search term '{search_term}' not found in context"
